# Maintenance Backend Step-by-Step Plan

This guide breaks the maintenance backend implementation into concrete steps that match the existing Spring Boot + MyBatis-Plus project structure. Follow the steps sequentially to deliver the complete workflow (user submit → admin assign → mechanican repair → admin confirm).

## Step 1. Set up the package skeleton

Mirror the layering conventions already used in `group5.sebm.user` by creating a new top-level package `group5.sebm.maintenance` with controller/service/dao/entity/enums sub-packages.

```
group5/sebm/maintenance
├── controller
│   ├── AdminMaintenanceController.java
│   ├── MechanicanMaintenanceController.java
│   ├── UserMaintenanceController.java
│   ├── dto
│   │   ├── AssignRequest.java
│   │   ├── SubmitMaintenanceRequest.java
│   │   ├── SubmitRepairRequest.java
│   │   └── VerifyMaintenanceRequest.java
│   └── vo
│       └── MaintenanceRecordVo.java
├── service
│   ├── AdminMaintenanceService.java
│   ├── MechanicanMaintenanceService.java
│   ├── UserMaintenanceService.java
│   ├── impl (if you prefer to keep implementations separate)
│   └── bo / converter (optional helpers)
├── dao
│   ├── DeviceMapper.java
│   ├── UserMaintenanceRecordMapper.java
│   └── MechanicanMaintenanceRecordMapper.java
├── entity
│   ├── DevicePo.java
│   ├── UserMaintenanceRecordPo.java
│   └── MechanicanMaintenanceRecordPo.java
└── enums
    ├── DeviceStatusEnum.java
    └── MaintenanceRecordStatusEnum.java
```

Create empty class placeholders (or interfaces) for the main components so that later steps can fill in logic. If a class needs a dedicated XML mapper, create a matching empty file under `src/main/resources/mapper/maintenance/`.

## Step 2. Model the database entities

Create MyBatis-Plus `@TableName` entity classes matching the schema shared in the specification:

- `DevicePo` → `device`
- `UserMaintenanceRecordPo` → `userMaintenanceRecord`
- `MechanicanMaintenanceRecordPo` → `mechanicanMaintenanceRecord`

Include the relevant fields (e.g., `status`, `description`, `image`, `createTime`, `updateTime`, `isDelete`) and enable `@TableLogic` for soft-delete flags where applicable, consistent with `UserPo`.

## Step 3. Replace magic numbers with enums

Define enums to replace "magic numbers":

- `DeviceStatusEnum` with values such as `AVAILABLE(1)`, `MAINTAINING(2)`, `RESERVED(3)` (extend with other statuses already present in the system).
- `MaintenanceRecordStatusEnum` for `PENDING`, `ASSIGNED`, `IN_PROGRESS`, `COMPLETED`, `REJECTED`, etc., so that both user and mechanican records can store workflow state transitions.

Add helper methods inside the enums to translate between database integers and business-friendly values, similar to `UserRoleEnum`.

## Step 4. Introduce DTOs and VOs

Create request/response models inside `controller/dto` and `controller/vo` packages to decouple API payloads from persistence objects:

- `SubmitMaintenanceRequest` → used by end users. Contains `deviceId`, `description`, `imageUrl`, optional contact info.
- `AssignRequest` → used by admins. Contains `maintenanceRecordId`, `mechanicanId`, `dueDate` (if needed).
- `SubmitRepairRequest` → used by mechanicans. Contains `mechanicanRecordId`, `description`, `imageUrl`, optional cost/time info.
- `VerifyMaintenanceRequest` → used by admins to confirm the repair, including final comments and pass/fail flag.
- `MaintenanceRecordVo` → aggregated view combining device info, user submission, assigned mechanican, and current status for list/detail endpoints.

Use converters (static methods or MapStruct) to avoid manual `BeanUtils` copying, just like `UserServiceImpl` currently does.

## Step 5. Implement service logic in phases

Implement the services incrementally, verifying each phase with tests or manual calls before moving to the next:

1. **UserMaintenanceService**
   1. Implement `submitRequest(SubmitMaintenanceRequest dto, Long userId)`
      - Validate device existence and availability (`DeviceMapper.selectById`).
      - Insert a `UserMaintenanceRecordPo` with status `PENDING`.
      - Update `device.status` to `MAINTAINING` and stamp `updateTime`.
      - Optionally create a `notificationRecord` for admins.
      - Wrap the above in `@Transactional` to keep DB updates consistent.
   2. Implement `listOwnRequests(Long userId, PageRequest)` to let users see submission history.

2. **AdminMaintenanceService**
   1. Implement `listPendingRequests(PageRequest)` to fetch user-submitted records waiting for assignment.
   2. Implement `assignMechanican(AssignRequest dto, Long adminId)`
      - Validate admin role via `@AuthCheck(mustRole = "admin")` in the controller.
      - Verify the target mechanican has the proper role (requires extending `UserRoleEnum` and storing mechanic role in the `user` table`).
      - Create or update a `MechanicanMaintenanceRecordPo` linked to the user record.
      - Update `UserMaintenanceRecord.status` to `ASSIGNED`.
      - Send notification to the mechanican (insert into `notificationRecord`).
   3. Implement `verifyRepair(VerifyMaintenanceRequest dto, Long adminId)`
      - Validate mechanican record exists and is completed.
      - Set user record status to `COMPLETED` or `REJECTED`.
      - Update `device.status` to `AVAILABLE` (or another state if rejected) and log an `operationLog` entry if the project uses that table.

3. **MechanicanMaintenanceService**
   1. Implement `listAssignedJobs(Long mechanicanId, PageRequest)`.
   2. Implement `submitRepairReport(SubmitRepairRequest dto, Long mechanicanId)`
      - Validate ownership of the assignment.
      - Persist description/image to `MechanicanMaintenanceRecord`.
      - Update status to `IN_PROGRESS` / `COMPLETED` as appropriate.
      - Notify admins for verification.

Each service should extend `ServiceImpl<Mapper, Po>` to reuse CRUD helpers, mirroring `UserServiceImpl`. Declare interfaces when multiple implementations are expected, or follow the current approach (e.g., `BorrowerServiceImpl` directly implements `UserService`).

## Step 6. Expose controller endpoints

Create dedicated controllers under `/maintenance` with RESTful endpoints:

- `/maintenance/user` (requires authenticated user)
  - `POST /request` → `submitRequest`
  - `GET /records` → `listOwnRequests`

- `/maintenance/admin` (guarded by `@AuthCheck(mustRole = "admin")`)
  - `GET /pending` → view unassigned requests
  - `POST /assign` → assign mechanican
  - `POST /verify` → finalize record

- `/maintenance/mechanican` (guarded by a new `@AuthCheck(mustRole = "mechanican")` once `UserRoleEnum` is extended)
  - `GET /assigned` → fetch assigned jobs
  - `POST /report` → upload repair outcome

Reuse `ResultUtils.success(...)` to wrap responses, matching the pattern in `UserController`.

## Step 7. Wire cross-cutting concerns

- **Role management**: Extend `UserRoleEnum` and the `AuthInterceptor` so that `mechanican` becomes a first-class role. Update the `user` table seed data or migration logic accordingly.
- **Validation**: Apply `@Valid` annotations on DTOs and add custom validators for uploaded images/description length.
- **Transactions**: Use `@Transactional` on service methods that touch multiple tables (e.g., user submission, assignment, verification) to keep statuses consistent.
- **Notifications**: Implement helper methods (or a `NotificationService`) to insert rows into `notificationRecord` and reuse existing templates from `notificationTemplate` if applicable.
- **Operation logs**: If `operationLog` is already used elsewhere, extend it to track assignment/verification events for auditing.

## Step 8. Add test coverage

- Create integration tests under `src/test/java/group5/sebm/maintenance` to cover the happy path scenario (user submit → admin assign → mechanican report → admin verify) using an in-memory database or transactional rollbacks.
- Add mapper tests to ensure custom queries join the correct tables.
- Mock notification service if it triggers external side effects.

## Step 9. Execute database and deployment migrations

1. Introduce the new packages, entities, and mappers.
2. Extend `UserRoleEnum` + `AuthInterceptor` to recognise the mechanican role.
3. Implement service logic with transactions and ensure device status transitions are consistent with the enumerations.
4. Wire controllers and expose endpoints via Swagger/OpenAPI annotations (`@Tag`), similar to existing controllers.
5. Add tests and, if required, database migration scripts (e.g., Flyway) to populate mechanic users.

Following this step-by-step checklist keeps the new maintenance workflow consistent with the existing project structure and coding standards while covering all role-specific responsibilities.
